
    
 (V)   Generate Ionograms (Calc_Ionograms.py) (creates lfm ... h5 files)
 
 # From calc_ionograms.py 
 
                  def get_m_per_Hz(rate):
 		   """
    			Determine resolution of a sounding.
    		   """
    			# rate = [Hz/s]
    			# 1/rate = [s/Hz]
    			dt=1.0/rate
    			# m/Hz round trip
    			return(dt*c.c/2.0)
  
  		   dr=conf.range_resolution
                  sr=conf.sample_rate
                  dec=2500                    %% [decimation]
                  sr_dec = sr/dec
                  ds=get_m_per_Hz(rate)
                  
                  fftlen = int(sr_dec*ds/dr/2.0)*2
                  fft_step=int((df/rate)*sr_dec)
  
                  range_gates=ds*n.fft.fftshift(n.fft.fftfreq(fftlen,d=1.0/sr_dec))
                  
                  
                  
                  ridx = n.where(n.abs(range_gates) < conf.max_range_extent)[0]
                  
                  ofname="%s/lfm_ionogram-%03d-%1.2f.h5"%(dname,cid,t0)

                  ho=h5py.File(ofname,"w")
                  ho["S"]=S[:,ridx]  # ionogram frequency-range
                  ho["freqs"]=freqs  # frequency bins
                  ho["rate"]=rate    # chirp-rate
                  
                  ho["ranges"]=range_gates[ridx]
                  
                  
 (VI)  Plot Ionograms (plot_Ionograms.py) (makes plot from the lfm  files)                 
                                   
 # From plot_ionograms.py 
                     
            fl = glob.glob("%s/lfm*.h5" % (conf.output_dir))
            for f in fl:
            	plot_ionogram(conf, f)
            
            ho = h5py.File(f, "r")
            t0 = float(n.copy(ho[("t0")]))
  
    	    cid = int(n.copy(ho[("id")]))  # ionosonde id
    	    
            S = n.copy(ho[("S")])          # ionogram frequency-range
            freqs = n.copy(ho[("freqs")])  # frequency bins
            
            ranges = n.copy(ho[("ranges")])  # range gates
            
            dt = (t0-n.floor(t0))
    	    dr = dt*c.c/1e3
            range_gates = dr+2*ranges/1e3
            r0 = range_gates[max_range_idx]
            
            
 Even if dr ~ 2000 km, the ranges are also high in numbers and dr compensates for it in the definition of range_gates where twice the ranges are added to 'dr'. 
 So, a better filter would be see if the spectrum maximizes below 1000 km in range_gates ! Instead of checking if dr < 1000 as we are seeing dr ~ 2000 but 
 range_gates can still maximize below 1000 km in the example we are working with. 
    
    
    

